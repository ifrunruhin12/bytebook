<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Class 31 - Slices - bytebook</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../../golang/intro.html"><strong aria-hidden="true">2.</strong> Golang</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../golang/go-with-habib-class-notes/go-with-habib-class-notes.html"><strong aria-hidden="true">2.1.</strong> Go With Habib Class Notes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../golang/go-with-habib-class-notes/class-0-go-basics.html"><strong aria-hidden="true">2.1.1.</strong> Go Basics</a></li><li class="chapter-item expanded "><a href="../../golang/go-with-habib-class-notes/class-16-package-scope.html"><strong aria-hidden="true">2.1.2.</strong> Class 16 - Package Scope</a></li><li class="chapter-item expanded "><a href="../../golang/go-with-habib-class-notes/class-17-scope-example.html"><strong aria-hidden="true">2.1.3.</strong> Class 17 - Scope Example</a></li><li class="chapter-item expanded "><a href="../../golang/go-with-habib-class-notes/class-18-variable-shadowing.html"><strong aria-hidden="true">2.1.4.</strong> Class 18 - Variable Shadowing</a></li><li class="chapter-item expanded "><a href="../../golang/go-with-habib-class-notes/class-19-function-types.html"><strong aria-hidden="true">2.1.5.</strong> Class 19 - Function Types</a></li><li class="chapter-item expanded "><a href="../../golang/go-with-habib-class-notes/class-20-init-function.html"><strong aria-hidden="true">2.1.6.</strong> Class 20 - Init Function</a></li><li class="chapter-item expanded "><a href="../../golang/go-with-habib-class-notes/class-21-anonymous-func-and-iife.html"><strong aria-hidden="true">2.1.7.</strong> Class 21 - Anonymous Functions and IIFE</a></li><li class="chapter-item expanded "><a href="../../golang/go-with-habib-class-notes/class-22-function-expression-example.html"><strong aria-hidden="true">2.1.8.</strong> Class 22 - Function Expression Example</a></li><li class="chapter-item expanded "><a href="../../golang/go-with-habib-class-notes/class-23-fof-vs-hof.html"><strong aria-hidden="true">2.1.9.</strong> Class 23 - Function of Function vs Higher Order Function</a></li><li class="chapter-item expanded "><a href="../../golang/go-with-habib-class-notes/class-24-internal-memory.html"><strong aria-hidden="true">2.1.10.</strong> Class 24 - Internal Memory</a></li><li class="chapter-item expanded "><a href="../../golang/go-with-habib-class-notes/class-25-end-of-internal-memory.html"><strong aria-hidden="true">2.1.11.</strong> Class 25 - End of Internal Memory</a></li><li class="chapter-item expanded "><a href="../../golang/go-with-habib-class-notes/class-26-closure.html"><strong aria-hidden="true">2.1.12.</strong> Class 26 - Closure</a></li><li class="chapter-item expanded "><a href="../../golang/go-with-habib-class-notes/class-27-struct.html"><strong aria-hidden="true">2.1.13.</strong> Class 27 - Struct</a></li><li class="chapter-item expanded "><a href="../../golang/go-with-habib-class-notes/class-28-receiver-function.html"><strong aria-hidden="true">2.1.14.</strong> Class 28 - Receiver Function</a></li><li class="chapter-item expanded "><a href="../../golang/go-with-habib-class-notes/class-29-array.html"><strong aria-hidden="true">2.1.15.</strong> Class 29 - Array</a></li><li class="chapter-item expanded "><a href="../../golang/go-with-habib-class-notes/class-30-pointers.html"><strong aria-hidden="true">2.1.16.</strong> Class 30 - Pointers</a></li><li class="chapter-item expanded "><a href="../../golang/go-with-habib-class-notes/class-31-slices.html" class="active"><strong aria-hidden="true">2.1.17.</strong> Class 31 - Slices</a></li></ol></li><li class="chapter-item expanded "><a href="../../golang/experiment/experiments.html"><strong aria-hidden="true">2.2.</strong> Experiments</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../golang/experiment/blank-identifier.html"><strong aria-hidden="true">2.2.1.</strong> Blank Identifier</a></li><li class="chapter-item expanded "><a href="../../golang/experiment/init-function.html"><strong aria-hidden="true">2.2.2.</strong> Init Function</a></li><li class="chapter-item expanded "><a href="../../golang/experiment/partial-redeclaration.html"><strong aria-hidden="true">2.2.3.</strong> Partial Declaration</a></li><li class="chapter-item expanded "><a href="../../golang/experiment/pointer-experiment.html"><strong aria-hidden="true">2.2.4.</strong> Pointer Experiment</a></li><li class="chapter-item expanded "><a href="../../golang/experiment/slice-capacity.html"><strong aria-hidden="true">2.2.5.</strong> Slice Capacity testing</a></li><li class="chapter-item expanded "><a href="../../golang/experiment/io-methods-golang.html"><strong aria-hidden="true">2.2.6.</strong> I/O methods in Golang</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">bytebook</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="-slice-deep-dive-in-go"><a class="header" href="#-slice-deep-dive-in-go">üìö Slice Deep Dive in Go</a></h1>
<hr />
<h1 id="-class-31-slice"><a class="header" href="#-class-31-slice">üìå Class 31: Slice</a></h1>
<h3 id="-key-topics"><a class="header" href="#-key-topics">üöÄ Key topics</a></h3>
<ol>
<li>What is a Slice?</li>
<li>How many parts does a Slice have?</li>
<li>How to determine Pointer, Length, and Capacity of a Slice?</li>
<li>Creating a Slice from an existing Array</li>
<li>Creating a Slice from an existing Slice</li>
<li>Slice Literal</li>
<li>Creating a Slice with <code>make()</code> (length only)</li>
<li>Creating a Slice with <code>make()</code> (length and capacity)</li>
<li>Creating an Empty or Nil Slice</li>
<li>Appending elements to a Slice</li>
<li>What happens internally when appending (Heap and Underlying Array behavior)</li>
<li>How the underlying array increases dynamically</li>
<li>Some interesting examples and interview questions</li>
<li>Variadic Functions</li>
</ol>
<hr />
<h1 id="-1-what-is-a-slice"><a class="header" href="#-1-what-is-a-slice">üß† 1. What is a Slice?</a></h1>
<ul>
<li>A <strong>slice</strong> is a lightweight data structure in Go.</li>
<li>Think of it like a dynamic view over an <strong>array</strong>.</li>
<li>Unlike arrays, slices can grow and shrink.</li>
</ul>
<p><strong>Key Points:</strong></p>
<ul>
<li>Slices are not arrays.</li>
<li>Slices are built <em>on top of</em> arrays.</li>
</ul>
<hr />
<h1 id="-2-how-many-parts-does-a-slice-have"><a class="header" href="#-2-how-many-parts-does-a-slice-have">üî• 2. How many parts does a Slice have?</a></h1>
<p>Under the hood, a Slice is a <strong>struct</strong> with three fields:</p>
<pre><code class="language-go">struct Slice {
    pointer *T // Pointer to the underlying array
    length  int // Current number of elements
    capacity int // Maximum number of elements (until reallocation)
}
</code></pre>
<p>You can think of a slice as a "window" into an array.</p>
<hr />
<h1 id="-3-how-to-determine-pointer-length-and-capacity"><a class="header" href="#-3-how-to-determine-pointer-length-and-capacity">üïµÔ∏è‚Äç‚ôÇÔ∏è 3. How to determine Pointer, Length, and Capacity</a></h1>
<p>Use:</p>
<ul>
<li><code>len(slice)</code> ‚û°Ô∏è Length</li>
<li><code>cap(slice)</code> ‚û°Ô∏è Capacity</li>
</ul>
<p>Example:</p>
<pre><code class="language-go">s := arr[1:4] // From index 1 to 3
fmt.Println(len(s)) // 3
fmt.Println(cap(s)) // depends on how much array is left after index 1
</code></pre>
<hr />
<h1 id="-4-creating-a-slice-from-an-existing-array"><a class="header" href="#-4-creating-a-slice-from-an-existing-array">üèó 4. Creating a Slice from an existing Array</a></h1>
<pre><code class="language-go">arr := [6]string{"This", "is", "a", "Go", "interview", "Questions"}
s := arr[1:4] // slice ["is", "a", "Go"]
</code></pre>
<ul>
<li><code>pointer</code>: points to index 1 of <code>arr</code></li>
<li><code>length</code>: 3 (from index 1 to 3)</li>
<li><code>capacity</code>: 5 (indexes 1 to 5)</li>
</ul>
<hr />
<h1 id="-5-creating-a-slice-from-an-existing-slice"><a class="header" href="#-5-creating-a-slice-from-an-existing-slice">üîÑ 5. Creating a Slice from an existing Slice</a></h1>
<pre><code class="language-go">s1 := s[1:2] // Slice "a"
</code></pre>
<ul>
<li>This slice is again a <strong>view</strong> into the same array!</li>
<li>Changing <code>s1</code> can affect <code>arr</code>.</li>
</ul>
<hr />
<h1 id="-6-slice-literal"><a class="header" href="#-6-slice-literal">‚úçÔ∏è 6. Slice Literal</a></h1>
<p>Create a slice without needing an array explicitly.</p>
<pre><code class="language-go">s2 := []int{3, 4, 7}
</code></pre>
<p>Here Go automatically creates an underlying array.</p>
<hr />
<h1 id="-7-creating-a-slice-with-make-length-only"><a class="header" href="#-7-creating-a-slice-with-make-length-only">üèóÔ∏è 7. Creating a Slice with <code>make()</code> (length only)</a></h1>
<pre><code class="language-go">s3 := make([]int, 3)
</code></pre>
<ul>
<li>Creates a slice of 3 zeroed elements.</li>
<li><code>len = 3</code>, <code>cap = 3</code></li>
</ul>
<hr />
<h1 id="-8-creating-a-slice-with-make-length-and-capacity"><a class="header" href="#-8-creating-a-slice-with-make-length-and-capacity">üèóÔ∏èüèóÔ∏è 8. Creating a Slice with <code>make()</code> (length and capacity)</a></h1>
<pre><code class="language-go">s4 := make([]int, 3, 5)
</code></pre>
<ul>
<li><code>len = 3</code>, but it can grow up to <code>cap = 5</code> before reallocating.</li>
</ul>
<hr />
<h1 id="-9-creating-an-empty-or-nil-slice"><a class="header" href="#-9-creating-an-empty-or-nil-slice">üï≥ 9. Creating an Empty or Nil Slice</a></h1>
<pre><code class="language-go">var s5 []int
</code></pre>
<ul>
<li><code>len = 0</code>, <code>cap = 0</code></li>
<li>Still valid! You can append to it.</li>
</ul>
<hr />
<h1 id="-10-appending-elements-to-a-slice"><a class="header" href="#-10-appending-elements-to-a-slice">‚ûï 10. Appending Elements to a Slice</a></h1>
<pre><code class="language-go">s6 := append(s6, 1)
</code></pre>
<ul>
<li>Go handles growing the underlying array if needed.</li>
<li>May involve <em>allocating a bigger array</em> and copying elements.</li>
</ul>
<hr />
<h1 id="-11-what-happens-internally-with-append"><a class="header" href="#-11-what-happens-internally-with-append">üß¨ 11. What Happens Internally with Append</a></h1>
<p>When a slice reaches capacity:</p>
<ul>
<li>A <strong>new array</strong> (usually double the size) is created.</li>
<li>Old elements are copied into the new array.</li>
</ul>
<p>This is why sometimes appending seems "fast" and sometimes causes big memory ops.</p>
<hr />
<h1 id="-12-how-underlying-array-increases"><a class="header" href="#-12-how-underlying-array-increases">üìà 12. How Underlying Array Increases</a></h1>
<p><strong>Capacity Growth Pattern:</strong> (simplified)</p>
<ul>
<li>Cap 1 ‚û°Ô∏è 2 ‚û°Ô∏è 4 ‚û°Ô∏è 8 ‚û°Ô∏è 16 ‚û°Ô∏è ...</li>
</ul>
<p>This is an optimization trick to ensure appends are amortized O(1).</p>
<hr />
<h1 id="go-slice-growth-understanding-the-dynamics-of-len-and-cap"><a class="header" href="#go-slice-growth-understanding-the-dynamics-of-len-and-cap">Go Slice Growth: Understanding the Dynamics of <code>len</code> and <code>cap</code></a></h1>
<p>Go slices are a powerful and flexible data structure, providing a dynamic array-like abstraction. One of the key features of slices is their ability to grow automatically when elements are appended. Understanding how and when a slice grows‚Äîalong with the mechanics of memory allocation‚Äîcan lead to more efficient use of slices in your programs.</p>
<p>In this document, we'll break down how Go slices grow, covering:</p>
<ul>
<li>The doubling of capacity when the slice's <code>len</code> and <code>cap</code> are less than 1024.</li>
<li>The 25% growth for slices when the <code>len</code> and <code>cap</code> exceed 1024.</li>
<li>Why a slice doesn't grow by a fixed amount, such as increasing from 1024 to 1280, but instead grows by larger, more optimized blocks (e.g., 1536).</li>
</ul>
<h2 id="slice-growth-overview"><a class="header" href="#slice-growth-overview">Slice Growth Overview</a></h2>
<p>In Go, slices are backed by arrays. When you append elements to a slice, Go may allocate a new, larger array and copy the old elements into it. The key to this resizing is how Go determines the new capacity and allocates memory.</p>
<h3 id="1-doubling-the-capacity-for-small-slices-lencap--1024"><a class="header" href="#1-doubling-the-capacity-for-small-slices-lencap--1024">1. Doubling the Capacity for Small Slices (<code>len(cap) &lt; 1024</code>)</a></h3>
<p>When the slice is relatively small (i.e., when the <code>len</code> and <code>cap</code> of the slice are both smaller than 1024), the growth strategy Go uses is to <strong>double</strong> the capacity. This means that when you append an element to the slice and the slice needs to resize, it will allocate a new array that is twice the size of the current capacity. The <code>len</code> of the slice will increase by one, but the <code>cap</code> will double.</p>
<h4 id="example"><a class="header" href="#example">Example:</a></h4>
<pre><code class="language-go">s := []int{1, 2, 3}
fmt.Println(len(s), cap(s)) // len: 3, cap: 3

s = append(s, 4)
fmt.Println(len(s), cap(s)) // len: 4, cap: 6

s = append(s, 5)
fmt.Println(len(s), cap(s)) // len: 5, cap: 12
</code></pre>
<ul>
<li>Initially, the slice has a length of 3 and a capacity of 3.</li>
<li>When we append the fourth element, the slice grows to a capacity of 6 (doubling from 3).</li>
<li>The next append results in the slice growing to a capacity of 12 (doubling from 6).</li>
</ul>
<h3 id="2-growth-by-25-for-larger-slices-lencap--1024"><a class="header" href="#2-growth-by-25-for-larger-slices-lencap--1024">2. Growth by 25% for Larger Slices (<code>len(cap) &gt;= 1024</code>)</a></h3>
<p>Once the slice grows to a size where its <code>len</code> and <code>cap</code> exceed or are equal to 1024, Go switches from doubling the capacity to increasing the capacity by <strong>25%</strong> of the current capacity. This growth strategy helps to strike a balance between minimizing frequent reallocations and not wasting too much memory.</p>
<h4 id="example-1"><a class="header" href="#example-1">Example:</a></h4>
<pre><code class="language-go">s := make([]int, 1024)  // len: 1024, cap: 1024
fmt.Println(len(s), cap(s))

s = append(s, 1025) // len: 1025, cap: 1280 (1024 + 25% of 1024)
fmt.Println(len(s), cap(s))

s = append(s, 1300) // len: 1300, cap: 1600 (1280 + 25% of 1280)
fmt.Println(len(s), cap(s))
</code></pre>
<ul>
<li>Initially, we create a slice with a length and capacity of 1024.</li>
<li>When appending the next element, the slice grows to a capacity of 1280, which is 1024 plus 25% of 1024.</li>
<li>Another append results in a capacity of 1600 (1280 plus 25% of 1280).</li>
</ul>
<h3 id="3-the-role-of-memory-blocks-eg-1536-for-a-slice"><a class="header" href="#3-the-role-of-memory-blocks-eg-1536-for-a-slice">3. The Role of Memory Blocks (e.g., 1536 for a Slice)</a></h3>
<p>When the slice's <code>len</code> and <code>cap</code> are near the threshold of 1024 (and higher), Go doesn't always allocate memory blocks in neat, predictable sizes like 1280. Instead, it aligns to <strong>optimal memory blocks</strong> that align better with system memory allocation patterns.</p>
<p>For example, if a slice's capacity is nearing 1024, the next allocation might not simply be an increment by 256 (i.e., from 1024 to 1280). Instead, Go will allocate memory in larger chunks to optimize memory usage and alignment. A common result of this optimization is the slice's capacity growing to <strong>1536</strong>, which is a more "perfect" memory block for larger sizes.</p>
<h4 id="why-1536-instead-of-1280"><a class="header" href="#why-1536-instead-of-1280">Why 1536 Instead of 1280?</a></h4>
<p>This behavior is largely based on <strong>hardware memory alignment</strong>. The number 1536 is chosen because it fits better with memory block sizes that are typically aligned in powers of 2 and optimized for modern CPUs and memory systems. Memory allocations are often made in chunks that align with the system‚Äôs memory page size or cache line, resulting in a more efficient memory access pattern.</p>
<h4 id="example-memory-alignment"><a class="header" href="#example-memory-alignment">Example (Memory Alignment):</a></h4>
<pre><code class="language-go">s := make([]int, 1024) // len: 1024, cap: 1024
fmt.Println(len(s), cap(s)) // 1024, 1024

s = append(s, 1025) // len: 1025, cap: 1536 (next optimal block size)
fmt.Println(len(s), cap(s)) // 1025, 1536
</code></pre>
<ul>
<li>The capacity grows from 1024 to 1536 rather than 1280, as 1536 is a better memory block that optimizes system memory allocation.</li>
</ul>
<h3 id="4-why-does-this-happen"><a class="header" href="#4-why-does-this-happen">4. Why Does This Happen?</a></h3>
<p>The reason Go doesn't strictly grow the slice by 256 (as one might expect, like going from 1024 to 1280) is due to <strong>efficiency considerations</strong>. The allocation strategy aims to reduce the number of reallocations while not wasting memory. By allocating a larger chunk (1536 in this case), the Go runtime ensures that the slice has enough room to accommodate several more appends without needing to resize again too soon.</p>
<p>This leads to better performance, especially in cases where slices grow rapidly.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>Understanding slice growth behavior can help you write more efficient Go code. When the slice is smaller, Go doubles its capacity to handle more elements with fewer reallocations. When the slice reaches a certain size (1024 and beyond), it increases capacity by 25%, and occasionally, it aligns the slice's capacity with optimal memory block sizes for better efficiency. This approach leads to smoother and more performant memory handling, ensuring that slices are both memory-efficient and fast to work with.</p>
<hr />
<h1 id="-13-interesting-interview-question-examples"><a class="header" href="#-13-interesting-interview-question-examples">ü§Ø 13. Interesting Interview Question Examples</a></h1>
<h3 id="-same-underlying-array-trick"><a class="header" href="#-same-underlying-array-trick">‚ö° Same Underlying Array Trick</a></h3>
<pre><code class="language-go">var x []int
x = append(x, 1)
x = append(x, 2)
x = append(x, 3)

y := x
x = append(x, 4)
y = append(y, 5)

x[0] = 10
fmt.Println(x)
fmt.Println(y)
</code></pre>
<ul>
<li><code>x</code> and <code>y</code> were sharing the same backing array.</li>
<li>Mutating one could affect both.</li>
</ul>
<p>After appending past the cap, they might split into their own arrays.</p>
<hr />
<h1 id="-14-variadic-functions"><a class="header" href="#-14-variadic-functions">üõ† 14. Variadic Functions</a></h1>
<p>Functions can accept an arbitrary number of arguments with <code>...</code>.</p>
<pre><code class="language-go">func variadic(numbers ...int) {
    fmt.Println(numbers)
}

variadic(2, 3, 4, 6, 8, 10)
</code></pre>
<p>Internally, <code>numbers</code> is just a <strong>slice</strong>!</p>
<hr />
<h1 id="-visualizing-slice-in-ram-for-arr-and-s"><a class="header" href="#-visualizing-slice-in-ram-for-arr-and-s">üß† Visualizing Slice in RAM (for <code>arr</code> and <code>s</code>)</a></h1>
<pre><code>Array arr (indexes):
[0] "This"
[1] "is"  &lt;- s.ptr points here
[2] "a"
[3] "Go"
[4] "interview"
[5] "Questions"

Slice s:
- ptr = &amp;arr[1]
- len = 3 ("is", "a", "Go")
- cap = 5 (from "is" to "Questions")
</code></pre>
<p>Memory Visualization:</p>
<pre><code>+---+---+---+---+---+---+
|This|is|a|Go|interview|Questions|
+---+---+---+---+---+---+
     ^   ^   ^
     s[0] s[1] s[2]
</code></pre>
<hr />
<h1 id="-full-code-with-detailed-comments"><a class="header" href="#-full-code-with-detailed-comments">üìÑ Full Code with Detailed Comments</a></h1>
<pre><code class="language-go">package main

import "fmt"

func main() {
	// Create an array of strings
	arr := [6]string{"This", "is", "a", "Go", "interview", "Questions"}
	fmt.Println(arr)

	// Create a slice from array indexes 1 to 3 (exclusive of 4)
	s := arr[1:4]
	fmt.Println(s) // [is a Go]

	// Create a slice from a slice
	s1 := s[1:2]
	fmt.Println(s1) // [a]
	fmt.Println(len(s1)) // 1
	fmt.Println(cap(s1)) // 4 (capacity depends on the underlying array)

	// Slice literal
	s2 := []int{3, 4, 7}
	fmt.Println("slice", s2, "lenght:", len(s2), "capacity:", cap(s2))

	// make() function with length only
	s3 := make([]int, 3)
	s3[0] = 5
	fmt.Println(s3)
	fmt.Println(len(s3))
	fmt.Println(cap(s3))

	// make() function with length and capacity
	s4 := make([]int, 3, 5)
	s4[0] = 5
	fmt.Println(s4)
	fmt.Println(len(s4))
	fmt.Println(cap(s4))

	// Empty slice
	var s5 []int
	fmt.Println(s5) // []

	// Appending elements to empty slice
	var s6 []int
	s6 = append(s6, 1)
	fmt.Println(s6) // [1]

	var s7 []int
	s7 = append(s7, 1, 2, 3)
	fmt.Println(s7, len(s7), cap(s7)) // [1 2 3] 3 3

	// Interview question: Sharing underlying array
	var x []int
	x = append(x, 1)
	x = append(x, 2)
	x = append(x, 3)

	y := x
	x = append(x, 4)
	y = append(y, 5)

	x[0] = 10

	fmt.Println(x) // [10 2 3 5]
	fmt.Println(y) // [10 2 3 5]

	// Another interview question
	slc := []int{1, 2, 3, 4, 5}
	slc = append(slc, 6)
	slc = append(slc, 7)

	slcA := slc[4:]

	slcY := changeSlice(slcA)

	fmt.Println(slc)  // [1 2 3 4 10 6 7]
	fmt.Println(slcY) // [10 6 7 11]
	fmt.Println(slc[0:8]) // [1 2 3 4 10 6 7 11]

	// Variadic function call
	variadic(2, 3, 4, 6, 8, 10)
}

// Function that changes the slice passed
func changeSlice(a []int) []int {
	a[0] = 10
	a = append(a, 11)
	return a
}

// Variadic function that takes multiple integers
func variadic(numbers ...int) {
	fmt.Println(numbers)
	fmt.Println(len(numbers))
	fmt.Println(cap(numbers))
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../golang/go-with-habib-class-notes/class-30-pointers.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../golang/experiment/experiments.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../golang/go-with-habib-class-notes/class-30-pointers.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../golang/experiment/experiments.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
